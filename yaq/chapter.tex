\chapter{\texttt{yaq}} \label{cha:yaq}

\clearpage

\section{Introduction}  % =========================================================================

\clearpage

\section{The \yaq Protocol}  % =========================================================================

% The yaq paper here

\subsection{Properties}

\subsection{Traits}

\clearpage

\section{Tools}

\subsection{\texttt{yaq-traits}}

\hypertarget{installation}{%
\subsubsection{installation}\label{installation}}

yaq-traits can be installed via
\href{https://pypi.org/project/yaq-traits/}{PyPI} or
\href{https://anaconda.org/conda-forge/yaq-traits}{conda-forge}.

\begin{codefragment}{bash}
$ pip install yaq-traits
\end{codefragment}

\begin{codefragment}{bash}
$ conda config --add channels conda-forge
$ conda install yaq-traits
\end{codefragment}

\hypertarget{definitions}{%
\subsubsection{definitions}\label{definitions}}

\begin{description}
\tightlist
\item[\href{https://avro.apache.org/docs/current/spec.html\#Protocol+Declaration}{Avro
Protocol (AVPR)}]
The Avro protocol is the fully specified description of the daemon. It
describes the exposed method signatures (names, arguments, defaults to
arguments, text description). In addition, yaq avpr files include
information about the configuration, state, and traits of a daemon. Avpr
is a JSON file.
\item[\href{https://github.com/toml-lang/toml}{TOML}]
TOML is a configuration file. Here, we use TOML files to specify the
minimum info about a daemon. (i.e. behavior and descriptions inherited
via traits is \emph{not} included in the TOML) A full reference is
available below.
\item[\href{https://yaq.fyi/traits/}{Trait}]
A trait is simply a collection of exposed methods, configuration, and
state used to encourage shared behavior among similar yaq daemons with
different implementations
\end{description}

\hypertarget{usage}{%
\subsubsection{usage}\label{usage}}

yaq-traits is a command line application.

\hypertarget{help}{%
\paragraph{help}\label{help}}

Help: learn more, right from your terminal.

\begin{codefragment}{bash}
$ yaq-traits --help
Usage: yaq-traits [OPTIONS] COMMAND [ARGS]...

Options:
  --version  Show the version and exit.
  --help     Show this message and exit.

Commands:
  check
  compose
\end{codefragment}

Try \texttt{yaq-traits\ \ -\/-help} to learn more about a particular
command.

\hypertarget{list}{%
\paragraph{list}\label{list}}

List: list available traits

\begin{codefragment}{bash}
$ yaq-traits list
has-limits
has-measure-trigger
has-position
has-turret
is-daemon
is-discrete
is-homeable
is-sensor
uses-i2c
uses-serial
uses-uart
\end{codefragment}

\hypertarget{compose}{%
\paragraph{compose}\label{compose}}

Compose: Convert a simplified TOML file to a fully specified AVPR. This
takes a path to a TOML file as an argument, and prints the AVPR to
standard out.

\begin{codefragment}{bash}
$ yaq-traits compose my-daemon.toml > my-daemon.avpr
\end{codefragment}

\hypertarget{get}{%
\paragraph{get}\label{get}}

Get: Retrieve a fully specified AVPR for a trait (similar to compose,
but not a full daemon). This takes a name of a trait as an argument, and
prints the AVPR to standard out.

\begin{codefragment}{bash}
$ yaq-traits get has-limits > has-limits.avpr
\end{codefragment}

\hypertarget{check}{%
\paragraph{check}\label{check}}

Check: Verify that an AVPR file matches current trait behavior. This
takes a path to an AVPR file as an argument, and prints a table of
traits and whether the trait was found to be accurate. If it fails, the
traits which are not specified are explicitly printed and a nonzero exit
status is returned. The primary intent of \texttt{check} is to be used
by Continuous Integration tests, which consistently get the latest
version and will alert you if there is a change to the traits.

\begin{codefragment}{bash}
$ yaq-traits check fake-continuous-hardware.avpr
+---------------------+----------+----------+
| trait               | expected | measured |
+---------------------+----------+----------+
| has-limits          | true     | true     |
| has-position        | true     | true     |
| has-turret          | false    | false    |
| is-daemon           | true     | false    |
| is-discrete         | false    | false    |
| is-homeable         | false    | false    |
| uses-i2c            | false    | false    |
| uses-serial         | false    | false    |
| uses-uart           | false    | false    |
| has-measure-trigger | false    | false    |
| is-sensor           | false    | false    |
+---------------------+----------+----------+
Error: failed to verify expected trait(s):
  is-daemon
\end{codefragment}

What to do when a check fails:

\begin{itemize}
\tightlist
\item
  check that you have the most up to date \texttt{yaq-traits}
\item
  check the
  \href{https://github.com/yaq-project/yaq-traits/blob/main/CHANGELOG.md}{changelog}
  for \texttt{yaq-traits} to see what has been changed recently
\item
  In many cases, the accompanying behavior change will be implemented in
  the \texttt{core} package for your language (e.g.
  \href{https://github.com/yaq-project/yaq-python/blob/main/yaqd-core/CHANGELOG.md}{Python}).
  If so, all you need to do is pin the version of core and rerun
  \texttt{yaq-traits\ compose}
\item
  if the change requires your attention, make the necessary code changes
  and then rerun \texttt{yaq-traits\ compose}
\item
  feel free to reach out to the \href{https://yaq.fyi/contact/}{yaq
  developers} or
  \href{https://github.com/yaq-project/yaq-traits/issues}{raise an
  issue} if you are unsure of what is needed
\end{itemize}

\hypertarget{yaq-toml-file-specification}{%
\subsubsection{yaq TOML file
specification}\label{yaq-toml-file-specification}}

In general, the TOML file is used to specify the minimal description of
a daemon. Inherited behavior from traits are not included. You may
assign or reassign the default value of the default, but should not
change the documentation, type, or arguments to a message. The same
format is used to specify traits within `yaq-traits`.

\hypertarget{frontmatter}{%
\paragraph{frontmatter}\label{frontmatter}}

These identifying information about the daemon are provided as top level
keys.

\begin{description}
\tightlist
\item[\textbf{protocol} (string)]
The name of the daemon. The equivalent for a trait definition is
\textbf{trait}.
\item[\textbf{doc} (string)]
A description of the daemon, rendered at the top of its documentation
page.
\item[\textbf{traits} (\{'items': 'string', 'type': 'array'\})]
List of traits implemented by the daemon. In trait definitions, the
analogous entry is \textbf{requires}, which lists traits that are
implied by using that trait. If a traits is implied by other traits
(e.g. \texttt{has-limits} requires \texttt{has-position}) the required
trait need not be specified. \texttt{is-daemon} must be specified by all
daemons.
\item[\textbf{hardware} (\{'items': 'string', 'type': 'array'\})]
A list of supported hardware, formatted as 'make:model'. Supported
hardware should also appear in
\href{https://github.com/yaq-project/yaq-fyi/blob/main/known-hardware.toml}{known-hardware}.
Used only for building documentation.
\end{description}

\hypertarget{links}{%
\paragraph{links}\label{links}}

The links are a map of arbitrary keys to URLs. In general links to
documentation, source, and a bugtracker are good to have. Additionally
links to the manufacturer/library used are common.

\begin{codefragment}{toml}\noop
[links]  # all optional, arbitrary keys supported
documentation = "https://yaq.fyi/daemons/example-daemon"
source = "https://git.example.com/example-daemon"
bugtracker = "https://git.example.com/example-daemon/-/issues"
\end{codefragment}

\hypertarget{installation-1}{%
\paragraph{installation}\label{installation-1}}

Installation is just like links, except with the specific goal of
pointing to installable package references. For python, this likely
includes a link to PyPI and/or conda-forge.

\begin{codefragment}{toml}\noop
[installation]  # all optional, arbitrary keys supported
PyPI = "https://pypi.org/project/yaqd-example"
conda-forge = "https://anaconda.org/conda-forge/yaqd-example"
\end{codefragment}

\hypertarget{types}{%
\paragraph{types}\label{types}}

All valid
\href{https://avro.apache.org/docs/current/spec.html\#schemas}{Avro
types} are valid for yaq.\\
In addition, \texttt{yaq-tratis} provides a definition for an
N-dimensional homogeneous array, which can be used by putting the string
\texttt{"ndarray"} as the type.\\
Unions of types are specified using TOML arrays.\\
Since TOML does not include a null value (and null is a valid default
value, distinct from not having a default) the string
\texttt{"\_\_null\_\_"} is used in place of the null literal. Note that
when referring to the \emph{type}, \texttt{"null"} is used, just as
\texttt{"int"} is used to specify the integer type.\\
Named types (e.g. records and enums) may be defined inline where they
are used, but may also be provided as an array of tables:

\begin{codefragment}{toml}\noop
[[types]]
name="Greeting"
type="record"
[[types.fields]]
name="message"
type="string"

[[types]]
name="Curse"
type="record"
# You may find inline tables/arrays more readable here
# Note that toml forbids multi-line inline tables (arrays can be multi-line)
fields = [{name="message", "type"="string"}]
\end{codefragment}

\hypertarget{config}{%
\paragraph{config}\label{config}}

Each config parameter is a table with the name of the parameter as the
key within the \texttt{{[}config{]}} table with the following keys:

\begin{description}
\tightlist
\item[\textbf{type} (required)]
Avro type definition, commonly a string such as \texttt{"int"} or
\texttt{"ndarray"}, but may be a table representing collection types or
a record or an array representing a union of types.
\item[\textbf{doc} (optional)]
A string description of the config parameter
\item[\textbf{default} (optional)]
The default value if the config parameter is omitted in the daemon
configuration. If no default is given, it is considered required.
\end{description}

A daemon may override the default value defined by a trait (or provide
one where none was given). Additionally, rather then overwriting the
doc, a key \textbf{addendum} may be added to provide additional context
to the variable (e.g. communicating that a parameter is required despite
a null default value being defined in the trait).

\begin{codefragment}{toml}\noop
[config]

[config.a_binary_config]
type = "boolean"
default = false
doc = "An example of a boolean config param"

[config.an_optional_array]
type = ["null", {type = "array", items = "int"}]
default = "__null__"

# Overriding a config from a trait
[config.baud_rate]
default = 57600
addendum = "I want to provide more info about why 57600 is the default"
\end{codefragment}

\hypertarget{state}{%
\paragraph{state}\label{state}}

The state is configured exactly the same as config, except that
\emph{all} state variable \emph{must} have a default value. The same
rules about overriding defaults and addenda apply to state variables.

\begin{codefragment}{toml}\noop
[state]

[state.a_binary_state]
type = "boolean"
default = true
doc = "An example of a boolean state variable"
\end{codefragment}

\hypertarget{messages}{%
\paragraph{messages}\label{messages}}

Messages are the exposed remote procedure calls over the TCP interface.
This follows closely the specification
\href{https://avro.apache.org/docs/current/spec.html\#Messages}{provided
by Avro}. Note that all errors in the Python implementation are treated
as strings, though that may change in the future.\\
If the request field is omitted, the default is \texttt{{[}{]}}, i.e. no
parameters.\\
If the response field is omitted, the default is \texttt{"null"}.\\
Messages defined by traits should be omitted, only messages unique to
the daemon should be included. Messages should not be overridden, as the
behavior being the same to the client program is the intent of the
traits system.

\begin{codefragment}{toml}\noop
[messages.set_int]
request = [{"name"="int_value", "type"="int"}]
doc = "Set an example int value."

[messages.get_int] response = "int"
doc = "Get the example int value."
\end{codefragment}

\hypertarget{yaq-avpr-file-specification}{%
\subsubsection{yaq AVPR file
specification}\label{yaq-avpr-file-specification}}

The AVPR files generated are compliant with the
\href{https://avro.apache.org/docs/current/spec.html\#Protocol+Declaration}{Avro
specification}, however \texttt{yaq-traits} does add additional
information such that the avpr alone can be used to render the
documentation.\\
The AVPR files include the complete list of \texttt{config} and
\texttt{state} (including those inherited from traits). The links
(including installation links) are also included. Additional keys
specifying which trait provided a method or config/state variable are
also added by \texttt{yaq-traits}


\subsection{\texttt{yaqd-control}}

\hypertarget{installation}{%
\subsubsection{installation}\label{installation}}

yaqd-control can be installed via
\href{https://pypi.org/project/yaqd-control/}{PyPI} or
\href{https://anaconda.org/conda-forge/yaqd-control}{conda-forge}.

\begin{codefragment}{bash}
$ pip install yaqd-control
\end{codefragment}

\begin{codefragment}{bash}
$ conda config --add channels conda-forge
$ conda install yaqd-control
\end{codefragment}

\hypertarget{usage}{%
\subsubsection{usage}\label{usage}}

yaqd-control is a command line application.

Help: learn more, right from your terminal.

\begin{codefragment}{bash}
$ yaqd --help
Usage: yaqd [OPTIONS] COMMAND [ARGS]...

Options:
  --help  Show this message and exit.

Commands:
  clear-cache
  disable
  edit-config
  enable
  list
  reload
  restart
  scan
  start
  status
  stop
\end{codefragment}

Try \texttt{yaqd\ \ -\/-help} to learn more about a particular command.

\hypertarget{the-cache}{%
\paragraph{the cache}\label{the-cache}}

yaqd-control keeps track of known daemons, referred to as the cache

Status: yaqd-control can quickly show you the status of all daemons in
yaqd-control's cache. This is usually the most used subcommand, as it
gives a quick overview of the system, which daemons are offline, and
which are currently busy.

\begin{codefragment}{bash}
$ yaqd status
+-----------+-------+--------------------------+------+---------+-------+
| host      | port  | kind                     | name | status  | busy  |
+-----------+-------+--------------------------+------+---------+-------+
| 127.0.0.1 | 38202 | system-monitor           | foo  | online  | False |
| 127.0.0.1 | 39054 | fake-continuous-hardware | bar  | online  | True  |
| 127.0.0.1 | 39055 | fake-continuous-hardware | baz  | online  | False |
| 127.0.0.1 | 39056 | fake-continuous-hardware | spam | offline | ?     |
| 127.0.0.1 | 37067 | fake-discrete-hardware   | ham  | online  | False |
| 127.0.0.1 | 37066 | fake-discrete-hardware   | eggs | online  | False |
+-----------+-------+--------------------------+------+---------+-------+
\end{codefragment}

List: this is essentially the same as \texttt{status} except that it
does not attempt to contact the daemons, so it does not give you
additional context. List supports a flag -\/-format which accepts "json"
or "toml".

\begin{codefragment}{bash}
$ yaqd list
+-----------+-------+--------------------------+------+
| host      | port  | kind                     | name |
+-----------+-------+--------------------------+------+
| 127.0.0.1 | 38202 | system-monitor           | foo  |
| 127.0.0.1 | 39054 | fake-continuous-hardware | bar  |
| 127.0.0.1 | 39055 | fake-continuous-hardware | baz  |
| 127.0.0.1 | 39056 | fake-continuous-hardware | spam |
| 127.0.0.1 | 37067 | fake-discrete-hardware   | ham  |
| 127.0.0.1 | 37066 | fake-discrete-hardware   | eggs |
+-----------+-------+--------------------------+------+
\end{codefragment}

Scan: Scanning allows you to add currently running daemons to the cache.

\begin{codefragment}{bash}
$ yaqd scan
scanning host 127.0.0.1 from 36000 to 39999...
...saw unchanged daemon fake-discrete-hardware:eggs on port 37066
...saw unchanged daemon fake-discrete-hardware:ham on port 37067
...found new daemon system-monitor:foo on port 38202
...found new daemon fake-continuous-hardware:bar on port 39054
...saw unchanged daemon fake-continuous-hardware:baz on port 39055
...known daemon fake-continuous-hardware:spam on port 39056 not responding
...done!
\end{codefragment}

Scan has some additional options, passed as flags on the command line,
which allow you to change the default scan range and host (for remotely
accessed daemons):

\begin{codefragment}{bash}
$ yaqd scan --help
Usage: yaqd scan [OPTIONS]

Options:
  --host TEXT      Host to scan.
  --start INTEGER  Scan starting point.
  --stop INTEGER   Scan stopping point.
  --help           Show this message and exit.
\end{codefragment}

Edit Config: yaqd-control provides an easy way to edit the default
config file location for a daemon kind. This uses your default editor
(EDITOR environment variable), and defaults to \texttt{notepad.exe} on
Windows, and \texttt{vi} on other platforms. Using yaqd-control to edit
config files means that you do not need to know the default location.
Additionally, it does some basic validity checks (that the toml parses
and that each daemon section has the \texttt{port} keyword). If an error
is found, you are prompted to re-edit the file. Daemons from the config
file are added to the cache. You may pass multiple daemon kinds, which
will be opened in succession.

\begin{codefragment}{bash}
$ yaqd edit-config fake-continuous-hardware system-monitor
\end{codefragment}

Clear Cache: Note that this is a destructive action.
\texttt{clear-cache} deletes all daemons from the cache (thus
\texttt{list} and \texttt{status} will give empty tables) There is no
user feedback.

\begin{codefragment}{bash}
$ yaqd clear-cache
$ yaqd status
+------+------+------+------+--------+------+
| host | port | kind | name | status | busy |
+------+------+------+------+--------+------+
+------+------+------+------+--------+------+
\end{codefragment}

\hypertarget{running-in-the-background}{%
\paragraph{Running in the
background}\label{running-in-the-background}}

Each of the commands in this section can take multiple daemon kinds.

Enable: by enabling a daemon, you allow the operating system to manage
that daemon in the background. An enabled daemon will always start again
when you restart your computer. Enabling is required for the rest of the
commands in this section to work as expected. After enabling, it's
typical to start the daemon as well, this does not happen automatically.
Enablement works in slightly different ways on different platforms, but
the commands are the same (don't worry if the password prompts are
different). Currently supported platforms are Linux (systemd), MacOS
(launchd) and Windows (via NSSM, bundled with the distribution).

\begin{codefragment}{bash}
$ yaqd enable system-monitor
[sudo] password for scipy2020:
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-unit-files ===
Authentication is required to manage system service or unit files.
Password:
==== AUTHENTICATION COMPLETE ===
\end{codefragment}

Disable: this is the inverse operation to enable, which makes it so that
the daemon does not start on reboot. This does not affect the running
daemon.

\begin{codefragment}{bash}
$ yaqd disable system-monitor
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-unit-files ===
Authentication is required to manage system service or unit files.
Password:
==== AUTHENTICATION COMPLETE ===
Removed /etc/systemd/system/multi-user.target.wants/yaqd-system-monitor.service.
\end{codefragment}

Start: This starts the daemon running in the background immediately. It
must have been enabled to run in the background using this command.

\begin{codefragment}{bash}
$ yaqd start system-monitor
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===
Authentication is required to start 'yaqd-system-monitor.service'.
Password:
==== AUTHENTICATION COMPLETE ===
\end{codefragment}

Stop: This stops the daemon running in the background immediately. It
must have been running in the background using yaqd-control (either on
startup via enable or via the start command above).

\begin{codefragment}{bash}
$ yaqd stop system-monitor
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===
Authentication is required to stop 'yaqd-system-monitor.service'.
Password:
==== AUTHENTICATION COMPLETE ===
\end{codefragment}

Restart/Reload: This stops (if running) and restarts the daemon running
in the background immediately. Reload is slightly different in that it
signals to the daemon to reload its configuration rather than completely
restart, but effectively it is the same as restart (and is a pure alias
where such a signal is not supported). It must have been enabled to run
in the background using this command.

\begin{codefragment}{bash}
$ yaqd restart system-monitor
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===
Authentication is required to restart 'yaqd-system-monitor.service'.
Password:
==== AUTHENTICATION COMPLETE ===
\end{codefragment}



\subsection{\texttt{yaqc-qtpy}}

\clearpage

\section{Guides}

\subsection{Writing a Daemon}

Intro, reference video of yaqd-new-era

First steps are to communicate with your hardware from python, ignore yaq entirely.
Look at manuals and documentations, look for manufacturer libraries
Reasonable to start interactively, consider making a script

Adding to an existing package or using a cookiecutter

Using cookiecutter
- answer questions
- name your package after manufacturer
- name your daemon

Output of the cookiecutter
- boilerplate
- pyproject.toml
	- defining entry points
- readme
- toml file for daemon
- py file for daemon

Existing package

Writing the toml file
- Consider what traits your daemon will implement
- Add additional messages, properties, types, config, state

Use yaq-traits to convert the toml file into avpr

Implementing the python
Import all of the classes from yaqd_core
Multiple inheritence, order matters

Define methods for each of the messages your protocol supports
Many are inherited via traits, and those traits may have more limited subsets that need to be implemented


Install via flit
Write a config file


\subsection{Configuration versus State}

\yaq{} provides two systems for dealing with values that persist across restarts of daemons: configuration and state.
These systems are similar, each providing values as TOML files, and thus the allowed set of values is the same.
Configuration values are set by the user and remain the same until the daemon is restarted.
State values are updated by the daemon itself, and can change while the daemon is running.
This may be in response to user input, such as calling a method over the \yaq{} interface, or simply by virtue of the daemon needing to keep track of its own state.

On the protocol level, configuration and state are defined in the same way: a name mapping to its type, documentation, and default value.
A configuration value may have no default, meaning that it is required that the user explicitly provides the value in the configuration file.
A state value must have a default, as the daemon may not be able to start without it.

\subsection{\yaq{} Enhancement Proposals}

\yaq{} Enhancement Proposals, or YEPs, are the formal process for standardizing the \yaq{} ecosystem.
YEPs are modeled after similar systems used by various open source communities including Python itself\cite{} and Numpy\cite{}.
YEPs include the formal definitions of various parts of the \yaq{} ecosystem, including the RPC itself and traits.

The purpose of the formalism of the YEP process is to encourage carefully considered additions to \yaq{}.
This means that there are a few extra steps compared to what is required for simply implementing an idea.
This friction is intentional.
The proposol must be submitted, and reviewed by the community, open for comment, criticism, and alternative solutions to the same problem.
YEPs start as draft proposals, submitted for initial review.
Core team members can ask for clarification of scope and metadata about the YEP itself prior to accepting the draft YEP.
Even if the YEP is included as a draft, it has not been accepted as a standard in the \yaq{} ecosytem.
Accepting a YEP requires at least two core maintainers to agree that the YEP should be considered a standard.

It is good practice to explain not only the suggested standard, but also briefly explain some alternatives that were considered and why the chosen standard is preferred.

\subsection{Implementing traits: has-dependents}

\texttt{has-dependents} provides a mechanism to discover relationships between daemons.
It provides a single method, \texttt{get\_dependent\_hardware}, which returns a map of names to host:port strings.

\begin{codefragment}{python}
class MyDaemon(HasDependents, IsDaemon):

    ...

    def get_dependent_hardware(self):
        return {"child": f"{self._wrapped_daemon._host}:{self._wrapped_daemon._port}"}
\end{codefragment}

\subsection{Implementing traits: has-limits}

\texttt{has-limits} augments \texttt{has-position} by adding boundaries which are queryable and checked when setting positions.
Most of the implementation is handled by the mix-in class, so the only consideration on the implementation side is to set the state value \texttt{hw\_limits}, which defines the limits imposed by the hardware itself.
Sometimes this can be read from the device, other times it is known through documentation, and still others there is no actual way to tell and the \texttt{hw\_limits} should be set to -infinity to +infinity.
Even in the latter case, it can be useful to include the \texttt{has-limits} trait because software limits can be imposed by users via configuration.

\subsection{Implementing traits: has-mapping}

\subsection{Implementing traits: has-measure-trigger}

\subsection{Implementing traits: has-position}

\texttt{has-position} is one of the most commonly used traits, and it is required by several other traits.
The central idea is that there is one value, the position, represented as a floating point number, which describes the core functionality of the daemon.
This is a value that might be scanned for an acquisition such as the color of a light source or position of a translation stage.
In \yaq{}, even hardware which is fundementally discrete, such as shutters or valves, are mapped to a floating point position variable for consistency, though interacting using the \texttt{is-discrete} trait may be more natural in those cases.

When implementing a \texttt{has-position} daemon, there are actually only a small number of things to consider, as much of the functionality is provided by the mix-in class.
You must consider the units of the position, if units are provided (they can be \texttt{None}, the default, if no units make logical sense).
You must implement the procedure for actually communicating with the hardware and setting the position: \texttt{\_set\_position}.
This is implemented as a private function (beginning with \texttt{\_}) because the mix-in class (and, in fact, some of the mix-in classes for related traits) manage setting of some state variables such as \texttt{destination}.
Next you must implement some mechanism of updating the state variable for \texttt{position}.
Depending on the hardware interface, this could mean polling the hardware for its direct knowledge of its position, updating the position in response to communication initated by the hardware, or even simply setting the state value in the position setting function if there is no mechanism to query the hardware.
Finally, you must carefully manage the \texttt{busy} state of the daemon.
It is expected that the daemon will return busy at every instance between the request being sent and the motion being complete.
\texttt{busy} is set to True by the mix-in class when the request is first processed, but it must be set back to False by the daemon implementation.
It is common to update both busy and position in the \texttt{update\_state} asynchronous method, though other options are valid.

\begin{codefragment}{python}
class MyDaemon(HasPosition, IsDaemon):
    def __init__(self, name, config, config_filepath):
        super().__init__(self, name, config, config_filepath)
        self.units = "mm"
        self.dev = Device() # Some generic manufacturer interface
    
    def _set_position(self, position):
        self.dev.write(position)

    async def update_state(self):
        while True:
            self._state["position"] = self.dev.read()
            self.busy = not self.dev.is_still()
            await asyncio.sleep(0.1)
\end{codefragment}

\subsection{Implementing traits: has-transformed-position}

At first, implementing \texttt{has-transformed-position} seems like a daunting task.
There are many methods that are implemented which naturally are all interconnected.
However, most of the heavy lifting is implemented by the mix-in class, leaving only a couple variables for the simplest case and optionally a couple methods for more complex cases.
If all you want is a simple shift of where the zero position is, then the default implementation will work and all you have to think about is setting the variable \texttt{self.\_native\_units} in the same manner as \texttt{self.\_units} for a generic \texttt{has-position} device.
Consideration for the default or setting the state value introduced by \texttt{has-transformed-position}, \texttt{native\_reference\_position}, at initialization time may be useful as well.

More complicated cases, such as those with non-unity transformation functions, must also implement two methods: \texttt{\_relative\_to\_transformed} and \texttt{\_transformed\_to\_relative}.
These two functions work together to provide the scaling factors between the native position and the transformed position.
They are referred to as ``relative'' rather than ``native'' because the mix-in class still manages adding and subtracting the \texttt{native\_reference\_position}.
The two functions must provide the expected inversion such that calling one on the result of the other returns the original input (within rounding errors).
Additional configuration and/or state values may be required to properly compute the transformation, but that will depend on the specific circumstances.

Additionaly some implementations may need to override the some of the methods, such as \texttt{set\_native\_reference} to properly update their state, such as the \texttt{yaqd-attune-delay} daemon offseting the spectral delay correction curve.

Because the mix-in class relies on calling methods of \texttt{HasPosition}, care should be taken to ensure that the \texttt{HasTransformedPosition} class appears \textit{before} \texttt{HasPosition} in the class declaration.

\begin{codefragment}{python}
class MyDaemon(HasTransformedPosition, HasPosition, IsDaemon):
    def __init__(self, name, config, config_filepath):
        super().__init__(name, config, config_filepath)
        self._native_units = "cm"
        self._units = "cc"

    def _relative_to_transformed(self, relative_position):
        return relative_position ** 3

    def _transformed_to_relative(self, transformed_position):
        return transformed_position ** (1/3)
\end{codefragment}

\subsection{Implementing traits: has-turret}

\texttt{has-turret} is designed for devices such as monochromators that have a secondary position called a "turret", such as the ones used for selecting gratings.
The trait has three methods, comprising one single \yaq{} property: \texttt{get\_turret}, \texttt{set\_turret}, and \texttt{get\_turret\_options}.
There is also a state value, \texttt{turret}, which stores the current value of the property.

To implement \texttt{has-turret}, the setter and the options getter must be implemented.
The options getter should return a list of string names which are valid options for \texttt{set\_turret}.
The getter is implemented by the \texttt{HasTurret} mix-in class, simply returning the value as stored in the state dictionary.

The state value can either be updated when it is set or asynchronously by reading from the device.

\begin{codefragment}{python}
class MyDaemon(HasTurret, IsDaemon):

    ...

    def get_turret_options(self):
	return ["ir", "vis", "uv"]

    def set_turret(self, turret):
    	self.device.set_turret(self.gratings[turret]["index"])
	self.device.set_position(self._state["destination"])
	self._calculate_limits()
\end{codefragment}

\subsection{Implementing traits: is-discrete}

\texttt{is-discrete} is an addition to \texttt{has-position} which allows you to provide a set of named positions which can be set by providing the name instead of the value.
The trait provides a standard configuration option, \texttt{identifiers}, which allows users to specify the named positions in config.
However, some hardware natively support the functionality, so those are allowed to ignore the configuration value and read the list of identifiers from the device.
If you are using the configuration values, then the only additional implementation consideration is to update the state value \texttt{position\_identifier} with the appropriate value (a string indicating the descrete position or None, indicating that the device is not at one of the named positions.
What it means to be "at" the named position will vary for the particular details of the hardware.
Some hardware will want a level of tolerance, some will always report an exact number, and some will not natively have any in-between values that are even possible.

\begin{codefragment}{python}
class MyDaemon(IsDiscrete, HasPosition, IsDaemon):
    ...
    async def update_state(self):
        while True:
            self._state["position"] = self.dev.read()
            self.busy = not self.dev.is_still()
            self._state["position_identifier"] = self.dev.get_position_name()
            await asyncio.sleep(0.1)
\end{codefragment}

\subsection{Implementing traits: is-homeable}

\texttt{is-homeable} is a trait which provides a single method, \texttt{home}, which must be implemented.

Notably, what ``home'' means in \yaq{} is ``Go to your limit to determine your absolute position, then return to your current destination''.
This is often \textit{not} the same as what an individual device will do when homing, which is often only the first half.
Additionally, homing is a task which takes time to complete, which is contrary to the \yaq{} philosophy which expects methods to return quickly.
As such, there are some common patterns to homing hardware where the \texttt{home} message itself initiates an asynchronous task that actually accomplishes homing.
The details of how each device knows when to move on will vary, but in general it looks something like:

\begin{codefragment}{python}
class MyDaemon(IsHomeable, HasPosition, IsDaemon):

    ...

    def home(self):
        self._busy = True
        self._loop.create_task(self._home())

    async def _home(self):
        self._homing = True
	self._done_homing = False
        self._busy = True
	self.device.home()
	while not self.device.homed():
            await asyncio.sleep(0.01)
        self.set_position(self._state["destination"])
        self._homing = False
\end{codefragment}

Care must be taken to avoid reporting that \texttt{busy} is False at any point during the homing procedure.

\subsection{Implementing traits: is-sensor}

\subsection{Implementing traits: uses-i2c}

\texttt{uses-i2c} is a trait which exists solely to standardize the name of the config value for the I2C address, \texttt{i2c\_addr}.

I2C (inter-integrated circuit) is a low-level communication protocol for serial communication designed for communication between two devices such as microcontollers\cite{}
SMBus\cite{} is a similar protocol that is slightly more strict, but largely is interoperable with I2C, and is thus included for the purposes of the \yaq{} trait.
I2C typically exists on a network with one primary device and a series of secondary devices.
The primary device controls the timing and generates requests for data from the secondary devices.
The address is an integer which is used to designate which secondary device should accept the data and write responses.

Most of the devices that currently exist in the \yaq{} ecosystem which implement this trait are intended to work with a Raspberry Pi, which provides direct access to an I2C bus via the General Purpose Input Output (GPIO) pins.

As I2C is a serial protocol, use of this trait requires the use and implementation of the \texttt{uses-serial} trait.

You can add a default value to your particular configuration if one makes sense for your hardware, though often it is reasonable to say that the address is required in all cases.

\subsection{Implementing traits: uses-serial}

\texttt{uses-serial} is a trait which defines only one message: \texttt{direct\_serial\_write(bytes message)}.
This trait is required by the \texttt{uses-i2c} and \texttt{uses-uart} traits.
The method provided by this trait is intended for use as a debugging tool, and not for normal operations.

To implement a \texttt{uses-serial} daemon, the programmer needs to simply implent the method directly.
You may wish to include logging data read from the device as a response to the command, though what makes sense will depend heavily on the hardware.

\begin{codefragment}{python}
class MyDaemon(UsesSerial, IsDaemon):

    ...

    def direct_serial_write(self, message: bytes) -> None:
        self.ser.write(message)
        out = self.ser.readline()
        self.logger.debug(f"direct serial write: {out.decode()}")
\end{codefragment}


\subsection{Implementing traits: uses-uart}

\texttt{uses-uart} is a trait which exists solely to standardize the names provided to common configuration values among Universal Asynchronous Receiver-Transmitter (UART) style communication.
Common examples of UART style communication are RS-232\cite{} and RS-485\cite{}.

As UART is a serial protocol, use of this trait requires the use and implementation of the \texttt{uses-serial} trait.

These devices will typically appear as a \texttt{COM<n>} port in Windows or something similar to \texttt{/dev/ttyACM0} in Linux.
The operating system specific identifier is the first config field specified by the \texttt{uses-uart} trait, \texttt{serial\_port}.
The second configuration value, \texttt{baud\_rate}, idicates the speed of data transmission, which must be the same for both devices on either end of the transmission.
Some devices have variable baud rates, while others have fixed baud rates.
In the latter case (or even if it is variable, but the device itself has a default) it often makes sense to add a default value for \texttt{baud\_rate} in the TOML file for the protocol.

\begin{codefragment}{toml}\noop
traits = ["uses-uart", "uses-serial", "is-daemon"]
[config]
baud_rate.default = 19200
\end{codefragment}

As a python implementation, the \texttt{UsesUart} class does nothing other than ensure that the required \texttt{UsesSerial} class is included in the class inheritance.
The config values defined by \texttt{uses-uart} are accessed in the normal fashion.

While devices using this trait may wish to consider using some of the more advanced patterns below, it is entirely valid to start with a simple PySerial\cite{} implementation as shown here:

\begin{codefragment}{python}
import serial
from yaqd_core import UsesUart, UsesSerial, IsDaemon

class MyDaemon(UsesUart, UsesSerial, IsDaemon):
    def __init__(self, name, config, config_filepath):
	super().__init__(name, config, config_filepath)
	self._ser = serial.Serial(config["serial_port"], config["baud_rate"])

    def close(self):
	self._ser.close()
\end{codefragment}

\subsection{Daemon patterns: Busy}

\subsection{Daemon patterns: loading and saving state}

Daemon state management is usually fairly automated such that individual daemon authors rarely need to think deeply on the subject.
State files are stored in a standard location as a TOML file as specified by YEP 103\cite{}
At initialization time, the file is read if it exists, and missing values are filled with the default value from the protocol definition.

These values are held in memory in a dictionary called \texttt{self.\_state}, which is updated by the daemon when the daemons state changes, either due to user interaction or due to changes read from the hardware itself.

On a regular schedule (approximately 10 Hz when a daemon is busy, and approximately 1 Hz when a daemon is not busy) the daemon will write out the contents of its in-memory state, if it has been updated.
Note that the daemon will acknowledge that the state is updated automatically only if the top level keys or values have been updated.
If you have a complicated state such as a nested dictionary, then you may wish to explicitly mark the state as updated by including \texttt{self.\_state.updated = True} when the dictionary is updated without updating the top level of the state.

\subsection{Daemon patterns: logging}

Logging can be a powerful tool for decyphering what a daemon is doing.
In the Python implementation, the logging system of \yaq{} is integrated with the standard library logging module\cite{}.
\yaq{} defines a few extra logging levels to conform to a non-python specific standard initially provided by sd-daemon\cite{} and syslogv\cite{}.
In practice, however, the extra levels are rarely used.

Each daemon instance has its own logger, \texttt{self.logger}, which is set up to properly format the log messages and print to STDERR and, if configured, output to a file as well.
Daemon implementors are encouraged to sprinkle helpful log messages where it makes sense.
Messages which are only useful in debugging specific contexts, particularly those that are verbose to the point of obscuring other log messages, should be included using \texttt{self.logger.debug(message)}.
By default, these messages will not be displayed, but by passing \texttt{--verbose} to the daemon command or editing the configuration file the debug logs will be included.
Messages about ordinary operations, particularly information provided at start up or shut down should be logged with \texttt{self.logger.info(message)}.
Logs related to errors, such as errors being reported by the hardware, or errors in communication with the hardware itself should be logged using \texttt{self.logger.error(message)}
Additionally, while less comonly used, \texttt{self.logger.warning(message)} exists for warning users of potential unexpected behavior, such as that caused by falling back to default values.

\begin{codefragment}{python}
class MyDaemon(IsDaemon):

    ...

    def test_logging(self):
        self.logger.debug("This is a debug message")
        self.logger.info("This is an informational message")
        self.logger.warning("This is a warning message")
        self.logger.error("This is an error message")
\end{codefragment}


\subsection{Daemon patterns: serial devices}

\subsection{Daemon patterns: async interfaces}

\clearpage
