\chapter{Acquistion} \label{cha:acq}

\newcommand\biab{\texttt{bluesky-in-a-box} }
\newcommand\yaq{\texttt{yaq} }
\newcommand\wrightfakes{\texttt{wright-fakes} }
\newcommand\wrightplans{\texttt{wright-plans} }

\clearpage

\section{Introduction}  % =========================================================================

\subsection{PyCMDS: Monolithic Data Acquisition Program}

\clearpage

\section{\texttt{yaqc-cmds}: Steps towards modularity}  % =============================================================

\section{\texttt{bluesky}: Fully modular data acquisition}  % ===================================================================

\subsection{\wrightplans}

Broadly, \wrightplans provides wrappers of the standard Bluesky built-in plans which add unit awareness and the idea of "constants", allowing setting of motors to algebraic expressions of other motors.
These plans each bear the name of the underlying Bluesky plan with the suffix ``\texttt{\_wp}'' which simply stands for \wrightplans and is included to differentiate from the built-in plans.
Additionally, \wrightplans provides specialized plans for performing tuning operations of OPAs.

\subsubsection{Units support}

Many of the standard built-in Bluesky plans create linearly spaced arrays in the native units for each device.
This proves limiting especially in the case of spectroscopy because different subfields often primarily work with different unit systems; A materials scientist often thinks in eV, while a molecular spectroscopist focusing on vibrational modes mostly thinks in wavenumbers ($cm^{-1}$).
Making it easy for scientists to think in the more natural unit system for their experiment was a priority.
This is even more critical because the units for energy and the units for wavelength are inversely proportional, so a linear spaced array of points in one unit is not the same as a linearly spaced array in an alternative unit.

A common pattern in the built-in Bluesky plans is to use a "variadic cycle", a repeating pattern of three to six arguments passed positionally where each set defines one axis of the scan.
Where this pattern was used in the underlying plan, \wrightplans adds the units as a string to the end of that cycle of arguments.
The exception to this is \texttt{scan\_nd\_wp}, which is specified as a single \texttt{cycler}\cite{} object to define the positions.
In this case, the units are specified as a dictionary mapping the device object to the unit string.
If the unit is not provided in the dictionary or the unit is given as \texttt{None}, then the native units of the device in question are used.

\subsubsection{Constants}

Constants allow setting of additional hardware during the course of a scan according to algebraic relationships.
Specifically, Constants allow for positions to be set to linear combinations of other hardware positions.
The simplest case of a Constant is one which is actually Constant throughout the scan.
For example, setting a monochromator to zero nanometers or a delay to one picosecond delay.
Another common example would be scanning two motors simultaneously, as in setting Delay 2 equal to the value of Delay 1.
The most complicated common usage of Constants is to track the phase matching condition of the experiment.
For example, setting a monochromator to the sum of three light sources for a nonlinear spectroscopy experiment.

Constants are also unit aware, with the constraint that each term of the expression have compatible units, meaning that the units can be converted to one another.
The algebra is performed on values in the Constant's specified units, so different resulting positions will occur for a Constant calculated in nanometers versus a Constant with an identical expression but units of wavenumbers.

\subsubsection{\texttt{scan\_wp}}

Scan performs a one dimensional acquisition of linearly spaced points.
If multiple motors are specified, each provides a start and stop position as well as their units, but there is only one keyword argument, \texttt{num}, which sets the number of points in the scan.
This is refered to as the "inner product" of the two lists.
Constants are allowed for scan, though the built-in functionality makes them largely superfluous.
It can, however, be easier to think in terms of either end points or expressions for different experiments.
Constants also have requirements regarding units that are not required for motors specified as endpoints.

\begin{codefragment}{python}
# a simple scan
scan0 = scan_wp([det], m0, 0, 1, "mm", num=11)
# a scan with multiple motors specified
scan1 = scan_wp([det], m0, 0, 1, "mm", m1, 2, 3, "mm", num=11)
# equivalent scan using constant of "1*m0 + 1.0" instead of additional axis
scan2 = scan_wp([det], m0, 0, 1, "mm", num=11, constants=[[m1, "mm", [(1, m0), (1.0, None)]]])
\end{codefragment}

\subsubsection{\texttt{list\_scan\_wp}}

List Scan is nearly equivalent to Scan, except that instead of specifying end points, an iterable list of positions is provided instead of endpoints and number of points.
Since List Scan provides each of the points that are scanned, there is no requirement that points are linearly spaced.
However, there is a requirement that each of the provided lists are the same length, as it is still doing an inner product.
This makes it a useful plan for logarithmically spaced points spanning multiple orders of magnitude\footnote{The built-in plans actually do provide a \texttt{log\_scan} plan which acts as \texttt{scan}, where the endpoints and number of points are specified, however that is de-facto deprecated in favor of \texttt{list\_scan\_wp}, so it was not wrapped. The latter plan additionally allows similar ease to do symmetric log scans about zero.}.
Similarly, Constants are provided as an option, though they are technically subsumed by the built-in functionality of a List Scan.

\begin{codefragment}{python}
# a simple list scan, equivalent to a "normal" scan
scan0 = list_scan_wp([det], m0, np.linspace(0, 1, 11), "mm")
# a list scan with non-linearly spaced points
scan1 = list_scan_wp([det], m0, [0, 1,  2, 5, 10], "mm")
# a list scan with multiple motors specified, one pseudolog spaced and one linearly spaced
scan2 = list_scan_wp([det], m0, [0, 1, 2, 5, 10], "mm", m1, [0, 1, 2, 3, 4], "mm", num=11)
\end{codefragment}

\subsubsection{\texttt{grid\_scan\_wp}}

Grid Scan is the "outer product" counterpart to Scan.
This plan provides a way of doing N-Dimensional scans, where each specified axis rather than scanning together scan against one another.
Grid Scan is the workhorse plan for many data acquisition tasks.
Similar to Scan, the axes are spacified as endpoints plus number of points, however each axis now has its own number of points instead of having a single number for all motors.
Constants are needed for Grid Scan because the built-in version does not have any mechanism to specify that two motors should move together rather than against each other.
Additionally, Constants provide a way to specify that some condition, such as that the monochromator tracks the sum of two or three light sources.

A Grid Scan with only one axis is equivalent to Scan, and the addition of constants means that most desired acquisitions can be accomplished with Grid Scan.

\begin{codefragment}{python}
\end{codefragment}

\subsubsection{\texttt{list\_grid\_scan\_wp}}

List Grid Scan is to Grid Scan what List Scan is to Scan: rather than specifying endpoints and number of points, lists are provided for each axis.
Similarly, this allows for scanning motor positions which are not linearly spaced, such as logarithmically spaced points.
Constants provbide the same benefits to List Grid Scan as they do to Grid Scan.

\begin{codefragment}{python}
\end{codefragment}

\subsubsection{\texttt{scan\_nd\_wp}}

Scan ND is the mechanism by which all of the previous plans actually work.
It is more complicated to use, and thus is rarely directly called, but it is also able to perform more unique scans than are provided by the parameterizations for more standard scans.
It is highly recommended to consider if an equivalent acquisition could be done using one of the above plans prior to reaching for Scan ND; The reparameterized plans provide gaurdrails which make it harder to be incorrect or to get unexpected results.
In fact, the behavior of Constants is also technically not required for Scan ND, though complicated examples involving multiple terms and unit conversion would be difficult to compute for a native Scan ND.

Instead of specifying motor motion independently to the plan, this is done prior and a single \texttt{cycler}\cite{} object is handed to the Scan ND plan.
This cycler can perform arbitrary inner and outer product computations to define a trajectory through N-dimensional motor space.
As such, it can be used to perform scans similar to at least simple versions of Constants, mixing axes that scan together with those that scan against each other.
The motors are the keys of the Cycler object.
Since there is no "variadic cycle" for Scan ND, \wrightplans unit support is provided via a separate keyword argument, \texttt{axis\_units}, a dictionary mapping the motors as keys to strings, the unit to use for that motor.

\begin{codefragment}{python}
\end{codefragment}


\subsubsection{\texttt{motortune}}

\begin{codefragment}{python}
\end{codefragment}

\subsubsection{\texttt{run\_intensity}}

\begin{codefragment}{python}
\end{codefragment}

\subsubsection{\texttt{run\_setpoint}}

\begin{codefragment}{python}
\end{codefragment}

\subsubsection{\texttt{run\_tune\_test}}

\begin{codefragment}{python}
\end{codefragment}

\subsubsection{\texttt{run\_holistic}}


\begin{codefragment}{python}
\end{codefragment}


\subsection{\texttt{bluesky-in-a-box}: Background Services to Collect Scientific Data}

\texttt{bluesky-in-a-box} runs all of the services using Docker\cite{}.
Specifically, \texttt{bluesky-in-a-box} uses Docker Compose\cite{} to simultaneously start and stop all services, accounting for dependencies between them.

\begin{figure}
\includegraphics[width=7in]{"acquisition/images/bluesky-in-a-box-architecture"}
\caption[\texttt{bluesky-in-a-box} architecture]{
A summary of the parts of the \texttt{bluesky-in-a-box} and the flow of data between them.
The parts above the line are all run inside of docker, and can be brought online and offline simultaneously.
The parts below the line are run on the host system and represent the more direct hardware access and the graphical programs to used to interact with the system.
}
\label{acq:fig:biab_arch}
\end{figure}

\subsubsection{Installation}
\label{biab-install}

\paragraph{Set up hardware virtualization}

Docker is a technology that allows running services in a controlled environment that is isolated from the programs on the host machine.
To do this, it takes advantage of hardware options on modern Central Processing Units (CPUs).
The hardware options are available on most CPUs, but are often turned off by default and must be turned on in the BIOS settings.
The name and location of this setting will depend on the make and model of the hardware, but often are identified by options with names like "KVM" or "Intel Virtualization Technology".
Technically, this should only be required for Windows and MacOS installations.

\paragraph{Set up WSL (Windows only)}

The docker containers for \texttt{bluesky-in-a-box} define a Linux\cite{} environment for each service.
Microsoft has invested in the Windows Subsystem for Linux (WSL)\cite{} to make running Linux environments on Windows machines efficient.
To install on Windows 10 or above, you simply need to open a command prompt as an administrator (cmd.exe or powershell) and run \texttt{wsl --install}.
The install process will prompt you to reboot the machine.
It is recommended to install a version of Linux into WSL explicitly, by running \texttt{wsl --install -d debian} (or whatever distribution is your preference).

\paragraph{Install Docker}

On Windows and MacOS, the preferred method of installing Docker is to install Docker Desktop\cite{}.
This is a standard installer wizard which will guide you through the steps to install.
Once installed, you should toggle a handful of settings.
Most notably, under the "Resources->WSL Integration", it should be enabled for all distributions installed.
Additionally "Docker Compose V2" should be enabled.
It is also recommended to consider your personal preference and purpose of using docker to determine if starting docker at login is desirable, if you want weekly tips for using Docker, or if you wish to send usage stats to Docker.
Note that Docker Desktop's license terms require a paid subscription for commercial use, however academic use continues to be free.

On Linux, mostly Docker is installed via the system package manager.
For a Debian or Ubuntu based system this would be:

\begin{codefragment}{bash}
sudo apt install docker.io
sudo apt install docker-compose
\end{codefragment}

It is recommended to add your user account to the \texttt{docker} group to avoid needing to use \texttt{sudo} to perform docker operations:

\begin{codefragment}{bash}
sudo usermod -aG docker $USER
\end{codefragment}

\paragraph{Configure available \yaq hardware}

This section assumes that the system has \yaq hardware running and set up to be listed by \texttt{yaqd list}.
If this is a development machine, it is recommended to install \ref{wright-fakes} prior to proceeding.

\texttt{bluesky-in-a-box} uses \texttt{happi}\cite{}, a project created by the Stanford Linear Accelerator Center (SLAC), to communicate what hardware is available to the \texttt{re-manager} and \texttt{hwproxy}.
It provides a standard way of declaring available hardware and how to create a Bluesky-compatible python object for each.
Using \texttt{happi} allows the possibility of easily and transparently using hardware supported by additional control layers beyond \texttt{yaq}.

\texttt{happi} is a python package that can be installed with either \texttt{conda install happi} or \texttt{pip install happi}.
This will install a Command Line Interface (CLI) Application to manage a database (stored as a JSON file) of available hardware.
In addition, for \texttt{happi} to be able to work with \yaq hardware you must \texttt{conda install yaqc-bluesky} or \texttt{pip install yaqc-bluesky}.

To get started, set up a configuration file for \texttt{happi}.
On Windows, start by creating a folder \nolinkurl{~\\AppData\\Local\\happi\\happi}
Inside of this folder, create a file, \nolinkurl{happi.ini} with the following contents (replacing \texttt{<USERNAME>} with the username that is appropriate for your system):

\begin{codefragment}{ini}
	\[[DEFAULT]
path = C:\Users\<USERNAME>\AppData\Local\happi\happi\happidb.json
\end{codefragment}

Follow this by running the following in a command prompt:

\begin{codefragment}{bash}
setx /s %COMPUTERNAME% /u %USERNAME% HAPPI_CFG %LOCALAPPDATA%/happi/happi/happi.ini
\end{codefragment}

This sets up an environment variable which is persistent between sessions that tells happi where to load and save changes.

The Linux equivalent would be to create \nolinkurl{~/.config/happi.ini} with the contents of path pointing to \nolinkurl{~/.local/share/happi/happidb.json}.

Once set up, you can add all \texttt{yaq} hardware by doing:

\begin{codefragment}{bash}
yaqd list --format happi | happi update -
\end{codefragment}

This exports all of the daemons that are recognized by \texttt{yaqd-control} into the happi database.
If hardware is added to the system (or information like the host or port are updated) then the same line will update happi again.

\paragraph{Configure data folder}

You should create a data folder where \texttt{bluesky-in-a-box} will place the generated \texttt{wt5} files.
The exact location does not particular matter, but \nolinkurl{~/bluesky-cmds-data} is what will be used in this document.

\paragraph{Download \texttt{bluesky-in-a-box} Docker configuration}

Clone the git repository for \biab:

\begin{codefragment}{bash}
git clone https://github.com/wright-group/bluesky-in-a-box
\end{codefragment}

There are a few options for the Docker Compose files, a template for the file is provided in the root of the \texttt{bluesky-in-a-box} repository.
Copy the template file, \nolinkurl{.env-example} to \nolinkurl{.env}, then edit it.
\texttt{HAPPI\_DB\_PATH} should be set to the full path of \nolinkurl{happidb.json} as specified in \nolinkurl{happi.ini} file above.
\texttt{WT5\_DATA\_PATH} should be set to the full path of the data folder specified above.
Finally, \texttt{TZ} should be set to the appropriate timezone where it is running, for example \texttt{America/Chicago}.


\paragraph{Start and update containers}
Start the docker engine, either by opening Docker Desktop (Windows) or by enabling the background docker service (Linux).
Navigate to the \biab folder in a command prompt.
If needed, pull new versions or switch to appropriate branches that contain the version of \biab that you need.
To build for the first time or to perform a standard update, run the following:

\begin{codefragment}{bash}
docker compose up --build
\end{codefragment}

That will suffice for most cases, however if you want to force a full rebuild, you can use:

\begin{codefragment}{bash}
docker compose build --no-cache
\end{codefragment}

This is most useful as a development tool to ensure that you are not accidentally relying on the state of your local system in ways that would not work on other machines.

Once the containers are built, you can start them using Docker Desktop by pressing the start button for \biab in the "Containers/Apps" tab.
This will start the pre-built containers without rebuilding them.
Rebuilding using the CLI is needed whenever the containers themselves are changed, most commonly for bumping the versions of installed software.

\subsubsection{\texttt{re-manager}}
\subsubsection{\texttt{zmq-proxy}}
\subsubsection{\texttt{WT5}}
\subsubsection{\texttt{mongo}}
\subsubsection{\texttt{redis}}
\subsubsection{\texttt{hwproxy}}
\subsubsection{Troubleshooting}

\subsection{\texttt{qserver}: Command Line Frontend to \texttt{bluesky-queueserver}}

\subsubsection{Installation}

\texttt{qserver} is included with the installation of the python package \texttt{bluesky-queueserver}.
As such it is installed via:

\begin{codefragment}{bash}
conda install bluesky-queueserver
\end{codefragment}

or:

\begin{codefragment}{bash}
pip install bluesky-queueserver
\end{codefragment}

\subsection{\texttt{bluesky-cmds}: Graphical Frontend to \texttt{bluesky-queueserver}}

\subsubsection{Installation}

\texttt{bluesky-cmds} is included with the installation of the python package \texttt{bluesky-cmds}.
However, the package is not yet available on conda, so conda systems should install the dependencies via conda first.
As such it is installed via:

\begin{codefragment}{bash}
conda install bluesky-queueserver-api appdirs click pyqtgraph pyside2 qtpy toml toolz wrighttools sympy bluesky-hwproxy bluesky-widgets
pip install bluesky-cmds --no-deps
\end{codefragment}

or:

\begin{codefragment}{bash}
pip install bluesky-cmds
\end{codefragment}

or, for development purposes (conda users should still install dependencies as above):

\begin{codefragment}{bash}
git clone https://github.com/wright-group/bluesky-cmds
cd bluesky-cmds
flit install --pth-file
\end{codefragment}

\subsubsection{Configuration}

If running locally, then the default configuration options should suffice.
To populate or edit the configuration file you can execute:

\begin{codefragment}{bash}
bluesky-cmds edit-config
\end{codefragment}

This will prompt you to populate the file with the default template if it does not already exist, and open the configuration file in a text editor.

The default template, appropriate for connecting to a \biab instance running on the local machine is shown below:

\begin{codefragment}{toml}
test=true # needed for minted TODO figure this out
[bluesky]
re-manager = "tcp://localhost:60615"
re-info = "tcp://localhost:60625"
hwproxy = "tcp://localhost:60620"
zmq-proxy = "localhost:5568"
\end{codefragment}

To run remotely, the host and port for each connected service can change as needed.

\subsection{\texttt{wright-fakes}: Simulated Hardware for Development}
\label{wright-fakes}

\wrightfakes is a collection of docker containers each running a single \yaq daemon.
\wrightfakes provides an entire system, mimicking a laser table, but using only fake daemons to represent motors.
It includes detectors, a monochromator, delays, neutral density wheels, and OPAs (including the component motors of the OPAs and delays).

This serves as a quick and easy way to start a suite of \yaq daemons which is consistent and provides the variety of hardware needed to thoroughly test the data acquisition software.

\subsubsection{Installation}
These instructions assume that Docker is already installed, for more information see the \ref{biab-install}.


Clone the git repository for \wrightfakes:

\begin{codefragment}{bash}
git clone https://github.com/wright-group/wright-fakes
\end{codefragment}

Inside of this repository there are folders for each available system (at time of writing, this is only \texttt{fs}).
Navigate in a command prompt to the folder for the system you wish to start and run:

\begin{codefragment}{bash}
docker compose up --build
\end{codefragment}

This builds the system of simulated daemons and starts running the daemons through docker.
If the port that is expected for a \yaq daemon is already in use, the container will fail to run, much the same as if you tried to run a second instance of a \yaq daemon


If you are using Docker Desktop, then you can restart the fake daemons from the "Containers/Apps" tab of the Docker Desktop application, in the same manner as \biab.

Once installed, you need to update the \texttt{yaqd-control} cache so that it knows about all of the daemons:

\begin{codefragment}{bash}
yaqd scan
\end{codefragment}

On Windows, this can be a long process, so you may wish to search only the ranges where actual daemons are running

\begin{codefragment}{bash}
yaqd scan --start=38001 --stop=38003
yaqd scan --start=38401 --stop=38403
yaqd scan --start=38451 --stop=38453
yaqd scan --start=38500 --stop=38501
yaqd scan --start=38550 --stop=38551
yaqd scan --start=38999 --stop=39000
yaqd scan --start=39301 --stop=39303
yaqd scan --start=39501 --stop=39508
yaqd scan --start=39601 --stop=39608
yaqd scan --start=39701 --stop=39703
yaqd scan --start=39876 --stop=39877
\end{codefragment}

\subsection{Bluesky Community and Ecosystem}
\subsubsection{\texttt{tiled}}
\subsubsection{\texttt{databroker}}

\clearpage
